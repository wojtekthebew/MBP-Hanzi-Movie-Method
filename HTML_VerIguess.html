<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Structured Mnemonic Generator</title>
    <style>
        :root {
            --bg-color: #ffffff;
            --text-color: #333333;
            --border-color: #dddddd;
            --primary-color: #007bff;
            --secondary-color: #6c757d;
            --hover-color: #f8f9fa;
        }

        [data-theme="dark"] {
            --bg-color: #1a1a1a;
            --text-color: #ffffff;
            --border-color: #444444;
            --primary-color: #0d6efd;
            --secondary-color: #6c757d;
            --hover-color: #2d2d2d;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
            transition: all 0.3s ease;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
        }

        .header {
            display: flex;
            justify-content: between;
            align-items: center;
            margin-bottom: 20px;
        }

        .theme-toggle {
            background: var(--primary-color);
            color: white;
            border: none;
            padding: 8px 16px;
            border-radius: 4px;
            cursor: pointer;
        }

        .tabs {
            display: flex;
            border-bottom: 1px solid var(--border-color);
            margin-bottom: 20px;
        }

        .tab {
            padding: 12px 24px;
            background: none;
            border: none;
            border-bottom: 2px solid transparent;
            color: var(--text-color);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .tab.active {
            border-bottom-color: var(--primary-color);
            color: var(--primary-color);
        }

        .tab:hover:not(.active) {
            background-color: var(--hover-color);
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .search-box {
            margin-bottom: 20px;
        }

        .search-box input {
            width: 100%;
            max-width: 400px;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
            color: var(--text-color);
        }

        .form-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input, select, textarea {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid var(--border-color);
            border-radius: 4px;
            background-color: var(--bg-color);
            color: var(--text-color);
            box-sizing: border-box;
        }

        select[multiple] {
            height: 120px;
        }

        textarea {
            resize: vertical;
            min-height: 80px;
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-right: 8px;
        }

        button[type="submit"] {
            background-color: var(--primary-color);
            color: white;
        }

        .help-text {
            font-size: 0.85em;
            color: var(--secondary-color);
            margin-top: 4px;
        }

        .item-list {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(300px, 1fr));
            gap: 15px;
        }

        .item-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 15px;
            background-color: var(--bg-color);
        }

        .item-card h4 {
            margin: 0 0 10px 0;
            color: var(--primary-color);
        }

        .item-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
        }

        .edit-btn {
            background-color: #28a745;
            color: white;
        }

        .delete-btn {
            background-color: #dc3545;
            color: white;
        }

        .empty-state {
            text-align: center;
            padding: 40px;
            color: var(--secondary-color);
        }

        .alert {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 12px 20px;
            border-radius: 4px;
            color: white;
            z-index: 1000;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .alert-success {
            background-color: #28a745;
        }

        .alert-error {
            background-color: #dc3545;
        }

        /* Modal Styles */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
        }

        .modal-content {
            background-color: var(--bg-color);
            margin: 10% auto;
            padding: 20px;
            border-radius: 8px;
            width: 90%;
            max-width: 500px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .close {
            color: var(--secondary-color);
            font-size: 24px;
            font-weight: bold;
            cursor: pointer;
        }

        .close:hover {
            color: var(--text-color);
        }

        .quick-add-btn {
            background: none;
            border: 1px solid var(--primary-color);
            color: var(--primary-color);
            padding: 4px 8px;
            margin-left: 8px;
            border-radius: 4px;
            cursor: pointer;
        }

        .quick-add-btn:hover {
            background-color: var(--primary-color);
            color: white;
        }

        .form-group-with-add {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .form-group-with-add select {
            flex: 1;
        }

        /* Advanced Search */
        .advanced-search {
            background-color: var(--hover-color);
            padding: 15px;
            border-radius: 6px;
            margin-bottom: 20px;
            border: 1px solid var(--border-color);
        }

        .search-fields {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 10px;
            margin-bottom: 10px;
        }

        .search-actions {
            display: flex;
            gap: 10px;
        }

        /* Undo/Redo */
        .undo-redo {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

        .undo-btn, .redo-btn {
            background-color: var(--secondary-color);
            color: white;
        }

        .undo-btn:disabled, .redo-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        /* Character Counters */
        .character-count {
            display: inline-block;
            background-color: var(--primary-color);
            color: white;
            border-radius: 12px;
            padding: 2px 8px;
            font-size: 0.8em;
            margin-left: 8px;
        }

        /* Tone Sections Display */
        .tone-sections {
            margin-top: 10px;
            font-size: 0.9em;
        }

        .tone-section-item {
            display: inline-block;
            background-color: var(--hover-color);
            padding: 2px 6px;
            border-radius: 4px;
            margin: 2px;
            border: 1px solid var(--border-color);
        }
    </style>
</head>
<body data-theme="light">
    <div class="container">
        <div class="header">
            <h1>Structured Mnemonic Generator</h1>
            <button class="theme-toggle" onclick="toggleTheme()">ðŸŒ“ Toggle Theme</button>
        </div>

        <!-- Undo/Redo Controls -->
        <div class="undo-redo">
            <button class="undo-btn" onclick="undo()" id="undoBtn" disabled>â†¶ Undo</button>
            <button class="redo-btn" onclick="redo()" id="redoBtn" disabled>â†· Redo</button>
        </div>
        
        <div class="tabs">
            <button class="tab active" onclick="openTab('actors', this)">Actors</button>
            <button class="tab" onclick="openTab('sets', this)">Sets</button>
            <button class="tab" onclick="openTab('props', this)">Props</button>
            <button class="tab" onclick="openTab('characters', this)">Characters</button>
        </div>

        <!-- Actors Tab -->
        <div id="actors" class="tab-content active">
            <h2>Actors</h2>
            <div class="search-box">
                <input type="text" id="actorSearch" placeholder="Search actors... (Press Escape to clear)" oninput="searchActors()">
            </div>
            <div class="form-grid">
                <div>
                    <h3 id="actorFormTitle">Add New Actor</h3>
                    <form id="actorForm" onsubmit="saveActor(event)">
                        <input type="hidden" id="actorId">
                        <div class="form-group">
                            <label>Name:</label>
                            <input type="text" id="actorName" required autofocus>
                        </div>
                        <div class="form-group">
                            <label>Pinyin Initial:</label>
                            <input type="text" id="actorPinyin">
                            <div class="help-text">First letter of pinyin name for sorting</div>
                        </div>
                        <div class="form-group">
                            <label>Image:</label>
                            <input type="file" id="actorImage" accept="image/*">
                            <div id="actorImagePreview" style="margin-top: 10px; max-width: 150px;"></div>
                        </div>
                        <button type="submit" id="actorSubmitBtn">Add Actor</button>
                        <button type="button" onclick="cancelActorEdit()" id="actorCancelBtn" style="display: none; background: #6c757d;">Cancel</button>
                    </form>
                </div>
            </div>
            <div id="actorsList" class="item-list"></div>
        </div>

        <!-- Sets Tab -->
        <div id="sets" class="tab-content">
            <h2>Set Locations</h2>
            <div class="search-box">
                <input type="text" id="setSearch" placeholder="Search sets... (Press Escape to clear)" oninput="searchSets()">
            </div>
            <div class="form-grid">
                <div>
                    <h3 id="setFormTitle">Add New Set</h3>
                    <form id="setForm" onsubmit="saveSet(event)">
                        <input type="hidden" id="setId">
                        <div class="form-group">
                            <label>Name:</label>
                            <input type="text" id="setName" required autofocus>
                        </div>
                        <div class="form-group">
                            <label>Tone Sections (JSON):</label>
                            <textarea id="setTones" rows="4" placeholder='{"1": "Garden Area", "2": "Main Hall", "3": "Courtyard"}'></textarea>
                            <div class="help-text">
                                <strong>Shift+Enter</strong> for new line, 
                                <strong>Enter</strong> to submit
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Image:</label>
                            <input type="file" id="setImage" accept="image/*">
                            <div id="setImagePreview" style="margin-top: 10px; max-width: 150px;"></div>
                        </div>
                        <button type="submit" id="setSubmitBtn">Add Set</button>
                        <button type="button" onclick="cancelSetEdit()" id="setCancelBtn" style="display: none; background: #6c757d;">Cancel</button>
                    </form>
                </div>
            </div>
            <div id="setsList" class="item-list"></div>
        </div>

        <!-- Props Tab -->
        <div id="props" class="tab-content">
            <h2>Props</h2>
            <div class="search-box">
                <input type="text" id="propSearch" placeholder="Search props... (Press Escape to clear)" oninput="searchProps()">
            </div>
            <div class="form-grid">
                <div>
                    <h3 id="propFormTitle">Add New Prop</h3>
                    <form id="propForm" onsubmit="saveProp(event)">
                        <input type="hidden" id="propId">
                        <div class="form-group">
                            <label>Name:</label>
                            <input type="text" id="propName" required autofocus>
                        </div>
                        <div class="form-group">
                            <label>Category:</label>
                            <select id="propCategory">
                                <option value="general">General</option>
                                <option value="weapon">Weapon</option>
                                <option value="clothing">Clothing</option>
                                <option value="artifact">Artifact</option>
                                <option value="document">Document</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Components (comma separated):</label>
                            <input type="text" id="propComponents">
                            <div class="help-text">Separate multiple components with commas</div>
                        </div>
                        <div class="form-group">
                            <label>Image:</label>
                            <input type="file" id="propImage" accept="image/*">
                            <div id="propImagePreview" style="margin-top: 10px; max-width: 150px;"></div>
                        </div>
                        <button type="submit" id="propSubmitBtn">Add Prop</button>
                        <button type="button" onclick="cancelPropEdit()" id="propCancelBtn" style="display: none; background: #6c757d;">Cancel</button>
                    </form>
                </div>
            </div>
            <div id="propsList" class="item-list"></div>
        </div>

        <!-- Characters Tab -->
        <div id="characters" class="tab-content">
            <h2>Characters</h2>
            
            <!-- Advanced Search -->
            <div class="advanced-search" id="characterAdvancedSearch" style="display: none;">
                <h4>Advanced Search</h4>
                <div class="search-fields">
                    <input type="text" id="searchHanzi" placeholder="Hanzi...">
                    <input type="text" id="searchPinyin" placeholder="Pinyin...">
                    <input type="text" id="searchMeaning" placeholder="Meaning...">
                    <select id="searchActor">
                        <option value="">Any Actor</option>
                    </select>
                    <select id="searchSet">
                        <option value="">Any Set</option>
                    </select>
                    <select id="searchProp">
                        <option value="">Any Prop</option>
                    </select>
                </div>
                <div class="search-actions">
                    <button onclick="performAdvancedSearch()">Search</button>
                    <button onclick="clearAdvancedSearch()" style="background: #6c757d;">Clear</button>
                    <button onclick="toggleAdvancedSearch()" style="background: #6c757d;">Close</button>
                </div>
            </div>
            
            <div class="search-box">
                <input type="text" id="characterSearch" placeholder="Search characters... (Press Escape to clear)" oninput="searchCharacters()">
                <button onclick="toggleAdvancedSearch()" style="margin-left: 10px;">Advanced Search</button>
            </div>
            
            <div class="form-grid">
                <div>
                    <h3 id="characterFormTitle">Add New Character</h3>
                    <form id="characterForm" onsubmit="saveCharacter(event)">
                        <input type="hidden" id="characterId">
                        <div class="form-group">
                            <label>Hanzi:</label>
                            <input type="text" id="charHanzi" required autofocus>
                        </div>
                        <div class="form-group">
                            <label>Pinyin:</label>
                            <input type="text" id="charPinyin" required>
                        </div>
                        <div class="form-group">
                            <label>Meaning:</label>
                            <input type="text" id="charMeaning" required>
                        </div>
                        <div class="form-group-with-add">
                            <label>Actor:</label>
                            <select id="charActor" required></select>
                            <button type="button" class="quick-add-btn" onclick="openQuickAddModal('actor')">+</button>
                        </div>
                        <div class="form-group-with-add">
                            <label>Set Location:</label>
                            <select id="charSet" required onchange="updateToneSections()"></select>
                            <button type="button" class="quick-add-btn" onclick="openQuickAddModal('set')">+</button>
                        </div>
                        <div class="form-group">
                            <label>Tone Section:</label>
                            <select id="charToneSection">
                                <option value="">Select a set location first</option>
                            </select>
                            <div class="help-text">Tone sections are based on the selected set location</div>
                        </div>
                        <div class="form-group-with-add">
                            <label>Props:</label>
                            <select id="charProps" multiple size="5"></select>
                            <button type="button" class="quick-add-btn" onclick="openQuickAddModal('prop')">+</button>
                        </div>
                        <div class="help-text">
                            Use <strong>Arrow keys</strong> to navigate, 
                            <strong>Space</strong> to toggle selection
                        </div>
                        <div class="form-group">
                            <label>Plot/Story:</label>
                            <textarea id="charPlot" rows="4" placeholder="Describe the mnemonic story or scene..."></textarea>
                            <div class="help-text">
                                <strong>Ctrl+Enter</strong> to submit
                            </div>
                        </div>
                        <div class="form-group">
                            <label>Image:</label>
                            <input type="file" id="charImage" accept="image/*">
                            <div id="charImagePreview" style="margin-top: 10px; max-width: 150px;"></div>
                        </div>
                        <button type="submit" id="characterSubmitBtn">Add Character</button>
                        <button type="button" onclick="cancelCharacterEdit()" id="characterCancelBtn" style="display: none; background: #6c757d;">Cancel</button>
                    </form>
                </div>
            </div>
            <div id="charactersList" class="item-list"></div>
        </div>
    </div>

    <!-- Quick Add Modals -->
    <div id="quickAddModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 id="quickAddModalTitle">Quick Add</h3>
                <span class="close" onclick="closeQuickAddModal()">&times;</span>
            </div>
            <form id="quickAddForm" onsubmit="saveQuickAddItem(event)">
                <div id="quickAddFormContent">
                    <!-- Dynamic form content will be inserted here -->
                </div>
                <button type="submit">Add</button>
                <button type="button" onclick="closeQuickAddModal()" style="background: #6c757d;">Cancel</button>
            </form>
        </div>
    </div>

    <script>
        // Data Storage - load from JSON files first
        const DATA = {
            ACTORS: [],
            SETS: [],
            PROPS: [],
            CHARACTERS: []
        };

        // File paths
        const ACTOR_FILE = 'Proper shit/data/actors.json';
        const SET_FILE = 'Proper shit/data/sets.json';
        const PROP_FILE = 'Proper shit/data/props.json';
        const CHARACTER_FILE = 'Proper shit/data/characters.json';
        const IMAGE_DIR = 'Proper shit/data/images';

        const STORAGE_KEYS = {
            ACTORS: ACTOR_FILE,
            SETS: SET_FILE,
            PROPS: PROP_FILE,
            CHARACTERS: CHARACTER_FILE
        };

        // Utility functions
        function getNextId(items) {
            if (!items.length) return '1';
            const maxId = Math.max(...items.map(item => parseInt(item.id) || 0));
            return (maxId + 1).toString();
        }

        // Check for duplicate names
        function isDuplicateName(type, name, excludeId = null) {
            const dataArray = DATA[type];
            return dataArray.some(item => 
                item.name.toLowerCase() === name.toLowerCase() && item.id !== excludeId
            );
        }

        // Handle image file upload (converts to base64 data URL or saves filename)
        function getImageDataURL(fileInput) {
            return new Promise((resolve) => {
                const file = fileInput.files[0];
                if (!file) {
                    resolve(null);
                    return;
                }
                const reader = new FileReader();
                reader.onload = (e) => {
                    resolve(e.target.result); // Returns data URL
                };
                reader.readAsDataURL(file);
            });
        }

        // Preview image in form
        function previewImage(fileInput, previewElementId) {
            const file = fileInput.files[0];
            const previewEl = document.getElementById(previewElementId);
            if (file) {
                const reader = new FileReader();
                reader.onload = (e) => {
                    previewEl.innerHTML = `<img src="${e.target.result}" style="max-width: 100%; border-radius: 4px;">`;
                };
                reader.readAsDataURL(file);
            } else {
                previewEl.innerHTML = '';
            }
        }

        function normalizeSeedData(key, arr) {
            if (!Array.isArray(arr)) return [];
            if (key === STORAGE_KEYS.PROPS) {
                return arr.map(p => {
                    // ensure components is array
                    if (typeof p.components === 'string') {
                        const comps = p.components.split(',').map(s => s.trim()).filter(Boolean);
                        p.components = comps.length ? comps : [p.components.trim() || ''];
                    } else if (!Array.isArray(p.components)) {
                        p.components = [];
                    }
                    if (!Array.isArray(p.used_by)) p.used_by = [];
                    return p;
                });
            }
            if (key === STORAGE_KEYS.SETS) {
                return arr.map(s => {
                    if (typeof s.tone_sections !== 'object' || s.tone_sections === null) s.tone_sections = {};
                    if (!Array.isArray(s.characters)) s.characters = [];
                    return s;
                });
            }
            if (key === STORAGE_KEYS.CHARACTERS) {
                return arr.map(c => {
                    if (!Array.isArray(c.props)) c.props = Array.isArray(c.props) ? c.props : (c.props ? [c.props] : []);
                    return c;
                });
            }
            if (key === STORAGE_KEYS.ACTORS) {
                return arr.map(a => {
                    if (!Array.isArray(a.characters)) a.characters = [];
                    return a;
                });
            }
            return arr;
        }

        // Load data from JSON files and populate DATA object
        async function loadDataFromFiles() {
            const files = [
                { file: ACTOR_FILE, key: 'ACTORS' },
                { file: SET_FILE, key: 'SETS' },
                { file: PROP_FILE, key: 'PROPS' },
                { file: CHARACTER_FILE, key: 'CHARACTERS' }
            ];

            await Promise.all(files.map(async ({ file, key }) => {
                try {
                    const res = await fetch(file);
                    if (res.ok) {
                        let data = await res.json();
                        data = normalizeSeedData(file, data);
                        DATA[key] = data;
                        console.log(`Loaded ${key} from ${file}`, data);
                    } else {
                        console.warn(`Failed to load ${file}: ${res.status}`);
                        DATA[key] = [];
                    }
                } catch (e) {
                    console.warn(`Error loading ${file}:`, e);
                    DATA[key] = [];
                }
            }));
        }

        // Undo/Redo System
        const HISTORY = {
            past: [],
            present: JSON.parse(JSON.stringify(DATA)),
            future: [],
            maxSteps: 20
        };

        function saveState() {
            HISTORY.past.push(JSON.parse(JSON.stringify(HISTORY.present)));
            HISTORY.present = JSON.parse(JSON.stringify(DATA));
            HISTORY.future = [];
            
            // Limit history size
            if (HISTORY.past.length > HISTORY.maxSteps) {
                HISTORY.past.shift();
            }
            
            updateUndoRedoButtons();
        }

        function updateUndoRedoButtons() {
            document.getElementById('undoBtn').disabled = HISTORY.past.length === 0;
            document.getElementById('redoBtn').disabled = HISTORY.future.length === 0;
        }

        function undo() {
            if (HISTORY.past.length === 0) return;
            
            HISTORY.future.unshift(JSON.parse(JSON.stringify(HISTORY.present)));
            HISTORY.present = HISTORY.past.pop();
            Object.assign(DATA, HISTORY.present);
            
            refreshLists();
            refreshCharacterForm();
            updateUndoRedoButtons();
            showAlert('Undo completed');
        }

        function redo() {
            if (HISTORY.future.length === 0) return;
            
            HISTORY.past.push(JSON.parse(JSON.stringify(HISTORY.present)));
            HISTORY.present = HISTORY.future.shift();
            Object.assign(DATA, HISTORY.present);
            
            refreshLists();
            refreshCharacterForm();
            updateUndoRedoButtons();
            showAlert('Redo completed');
        }

        // Theme Management
        function toggleTheme() {
            const body = document.body;
            const currentTheme = body.getAttribute('data-theme');
            const newTheme = currentTheme === 'light' ? 'dark' : 'light';
            body.setAttribute('data-theme', newTheme);
        }

        // Utility Functions
        function showAlert(message, type = 'success') {
            const alert = document.createElement('div');
            alert.className = `alert alert-${type}`;
            alert.textContent = message;
            document.body.appendChild(alert);
            setTimeout(() => alert.remove(), 3000);
        }

        // Character Counter Functions
        function getCharacterCountForActor(actorId) {
            return DATA.CHARACTERS.filter(char => char.actor === actorId).length;
        }

        function getCharacterCountForSet(setId) {
            return DATA.CHARACTERS.filter(char => char.set_location === setId).length;
        }

        function getCharacterCountForProp(propId) {
            return DATA.CHARACTERS.filter(char => char.props.includes(propId)).length;
        }

        // Tab Management
        function openTab(tabName, clickedButton) {
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.classList.remove('active');
            });
            document.querySelectorAll('.tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            document.getElementById(tabName).classList.add('active');
            if (clickedButton) {
                clickedButton.classList.add('active');
            }
            
            // Focus first field when switching tabs
            setTimeout(() => {
                const firstInput = document.querySelector(`#${tabName} input, #${tabName} select, #${tabName} textarea`);
                if (firstInput) {
                    firstInput.focus();
                }
            }, 100);
            
            if (tabName === 'characters') {
                refreshCharacterForm();
                refreshAdvancedSearchOptions();
            }
            refreshLists();
        }

        // Quick Add Modal Functions
        let currentQuickAddType = '';

        function openQuickAddModal(type) {
            currentQuickAddType = type;
            const modal = document.getElementById('quickAddModal');
            const title = document.getElementById('quickAddModalTitle');
            const formContent = document.getElementById('quickAddFormContent');
            
            title.textContent = `Quick Add ${type.charAt(0).toUpperCase() + type.slice(1)}`;
            formContent.innerHTML = getQuickAddFormHTML(type);
            
            modal.style.display = 'block';
            
            // Focus first input
            setTimeout(() => {
                const firstInput = formContent.querySelector('input, select, textarea');
                if (firstInput) firstInput.focus();
            }, 100);
        }

        function closeQuickAddModal() {
            document.getElementById('quickAddModal').style.display = 'none';
            document.getElementById('quickAddForm').reset();
        }

        function getQuickAddFormHTML(type) {
            switch(type) {
                case 'actor':
                    return `
                        <div class="form-group">
                            <label>Name:</label>
                            <input type="text" name="name" required>
                        </div>
                        <div class="form-group">
                            <label>Pinyin Initial:</label>
                            <input type="text" name="pinyin">
                        </div>
                    `;
                case 'set':
                    return `
                        <div class="form-group">
                            <label>Name:</label>
                            <input type="text" name="name" required>
                        </div>
                        <div class="form-group">
                            <label>Tone Sections (JSON):</label>
                            <textarea name="tones" rows="3" placeholder='{"1": "Area 1", "2": "Area 2"}'></textarea>
                        </div>
                    `;
                case 'prop':
                    return `
                        <div class="form-group">
                            <label>Name:</label>
                            <input type="text" name="name" required>
                        </div>
                        <div class="form-group">
                            <label>Category:</label>
                            <select name="category">
                                <option value="general">General</option>
                                <option value="weapon">Weapon</option>
                                <option value="clothing">Clothing</option>
                                <option value="artifact">Artifact</option>
                                <option value="document">Document</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label>Components:</label>
                            <input type="text" name="components" placeholder="comma separated">
                        </div>
                    `;
                default:
                    return '';
            }
        }

        function saveQuickAddItem(event) {
            event.preventDefault();
            const formData = new FormData(event.target);
            
            switch(currentQuickAddType) {
                case 'actor':
                    const newActor = {
                        id: getNextId(DATA.ACTORS),
                        name: formData.get('name'),
                        PinyinInitial: formData.get('pinyin'),
                        characters: []
                    };
                    DATA.ACTORS.push(newActor);
                    break;
                    
                case 'set':
                    let toneSections = {};
                    try {
                        const tonesInput = formData.get('tones').trim();
                        if (tonesInput) {
                            toneSections = JSON.parse(tonesInput);
                        }
                    } catch (e) {
                        showAlert('Invalid JSON format for Tone Sections', 'error');
                        return;
                    }
                    
                    const newSet = {
                        id: getNextId(DATA.SETS),
                        name: formData.get('name'),
                        tone_sections: toneSections,
                        characters: []
                    };
                    DATA.SETS.push(newSet);
                    break;
                    
                case 'prop':
                    const newProp = {
                        id: getNextId(DATA.PROPS),
                        name: formData.get('name'),
                        category: formData.get('category'),
                        components: formData.get('components').split(',').map(c => c.trim()).filter(c => c !== ''),
                        used_by: []
                    };
                    DATA.PROPS.push(newProp);
                    break;
            }
            
            saveState();
            refreshLists();
            refreshCharacterForm();
            closeQuickAddModal();
            showAlert(`${currentQuickAddType.charAt(0).toUpperCase() + currentQuickAddType.slice(1)} added successfully`);
            
            // Select the newly added item in the character form
            const newItemId = getNextId(DATA[currentQuickAddType.toUpperCase()]);
            const actualId = (parseInt(newItemId) - 1).toString();
            document.getElementById(`char${currentQuickAddType.charAt(0).toUpperCase() + currentQuickAddType.slice(1)}`).value = actualId;
            
            if (currentQuickAddType === 'set') {
                updateToneSections();
            }
        }

        // Advanced Search Functions
        function toggleAdvancedSearch() {
            const advancedSearch = document.getElementById('characterAdvancedSearch');
            advancedSearch.style.display = advancedSearch.style.display === 'none' ? 'block' : 'none';
        }

        function refreshAdvancedSearchOptions() {
            const actorSelect = document.getElementById('searchActor');
            const setSelect = document.getElementById('searchSet');
            const propSelect = document.getElementById('searchProp');
            
            actorSelect.innerHTML = '<option value="">Any Actor</option>';
            setSelect.innerHTML = '<option value="">Any Set</option>';
            propSelect.innerHTML = '<option value="">Any Prop</option>';
            
            DATA.ACTORS.forEach(actor => {
                const option = document.createElement('option');
                option.value = actor.id;
                option.textContent = actor.name;
                actorSelect.appendChild(option);
            });
            
            DATA.SETS.forEach(set => {
                const option = document.createElement('option');
                option.value = set.id;
                option.textContent = set.name;
                setSelect.appendChild(option);
            });
            
            DATA.PROPS.forEach(prop => {
                const option = document.createElement('option');
                option.value = prop.id;
                option.textContent = prop.name;
                propSelect.appendChild(option);
            });
        }

        function performAdvancedSearch() {
            const hanzi = document.getElementById('searchHanzi').value.toLowerCase();
            const pinyin = document.getElementById('searchPinyin').value.toLowerCase();
            const meaning = document.getElementById('searchMeaning').value.toLowerCase();
            const actor = document.getElementById('searchActor').value;
            const set = document.getElementById('searchSet').value;
            const prop = document.getElementById('searchProp').value;
            
            const filteredCharacters = DATA.CHARACTERS.filter(character => {
                if (hanzi && !character.hanzi.toLowerCase().includes(hanzi)) return false;
                if (pinyin && !character.pinyin.toLowerCase().includes(pinyin)) return false;
                if (meaning && !character.meaning.toLowerCase().includes(meaning)) return false;
                if (actor && character.actor !== actor) return false;
                if (set && character.set_location !== set) return false;
                if (prop && !character.props.includes(prop)) return false;
                return true;
            });
            
            displayCharacters(filteredCharacters);
        }

        function clearAdvancedSearch() {
            document.getElementById('searchHanzi').value = '';
            document.getElementById('searchPinyin').value = '';
            document.getElementById('searchMeaning').value = '';
            document.getElementById('searchActor').value = '';
            document.getElementById('searchSet').value = '';
            document.getElementById('searchProp').value = '';
            displayCharacters();
        }

        // Keyboard Navigation Setup
        function setupKeyboardNavigation() {
            // Actors Tab Navigation
            const actorName = document.getElementById('actorName');
            const actorPinyin = document.getElementById('actorPinyin');
            
            if (actorName && actorPinyin) {
                actorName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        actorPinyin.focus();
                    }
                });
                
                actorPinyin.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('actorSubmitBtn').click();
                    }
                });
            }

            // Sets Tab Navigation
            const setName = document.getElementById('setName');
            const setTones = document.getElementById('setTones');
            
            if (setName && setTones) {
                setName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        setTones.focus();
                    }
                });
                
                setTones.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && !e.shiftKey) {
                        e.preventDefault();
                        document.getElementById('setSubmitBtn').click();
                    }
                });
            }

            // Props Tab Navigation
            const propName = document.getElementById('propName');
            const propCategory = document.getElementById('propCategory');
            const propComponents = document.getElementById('propComponents');
            
            if (propName && propCategory && propComponents) {
                propName.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        propCategory.focus();
                    }
                });
                
                propCategory.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        propComponents.focus();
                    }
                });
                
                propComponents.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('propSubmitBtn').click();
                    }
                });
            }

            // Characters Tab Navigation
            const charHanzi = document.getElementById('charHanzi');
            const charPinyin = document.getElementById('charPinyin');
            const charMeaning = document.getElementById('charMeaning');
            const charActor = document.getElementById('charActor');
            const charSet = document.getElementById('charSet');
            const charToneSection = document.getElementById('charToneSection');
            const charProps = document.getElementById('charProps');
            const charPlot = document.getElementById('charPlot');
            
            if (charHanzi) {
                charHanzi.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charPinyin.focus();
                    }
                });
            }
            
            if (charPinyin) {
                charPinyin.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charMeaning.focus();
                    }
                });
            }
            
            if (charMeaning) {
                charMeaning.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charActor.focus();
                    }
                });
            }
            
            if (charActor) {
                charActor.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charSet.focus();
                    }
                });
            }
            
            if (charSet) {
                charSet.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charToneSection.focus();
                    }
                });
            }
            
            if (charToneSection) {
                charToneSection.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charProps.focus();
                    }
                });
            }
            
            // Props multi-select navigation
            if (charProps) {
                charProps.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        charPlot.focus();
                    } else if (e.key === ' ') {
                        e.preventDefault();
                        const selectedOption = charProps.options[charProps.selectedIndex];
                        if (selectedOption) {
                            selectedOption.selected = !selectedOption.selected;
                        }
                    }
                });
            }
            
            // Plot textarea with Ctrl+Enter to submit
            if (charPlot) {
                charPlot.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter' && e.ctrlKey) {
                        e.preventDefault();
                        document.getElementById('characterSubmitBtn').click();
                    }
                });
            }

            // Search boxes - Escape to clear
            const searchBoxes = ['actorSearch', 'setSearch', 'propSearch', 'characterSearch'];
            searchBoxes.forEach(id => {
                const searchBox = document.getElementById(id);
                if (searchBox) {
                    searchBox.addEventListener('keydown', (e) => {
                        if (e.key === 'Escape') {
                            e.preventDefault();
                            searchBox.value = '';
                            // Trigger the search to show all items
                            if (id === 'actorSearch') searchActors();
                            else if (id === 'setSearch') searchSets();
                            else if (id === 'propSearch') searchProps();
                            else if (id === 'characterSearch') searchCharacters();
                        }
                    });
                }
            });

            // Close modal with Escape
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    closeQuickAddModal();
                }
            });
        }

        // Actor Functions
        function saveActor(event) {
            event.preventDefault();
            const actorId = document.getElementById('actorId').value;
            const actorName = document.getElementById('actorName').value;
            
            // Check for duplicates
            if (isDuplicateName('ACTORS', actorName, actorId)) {
                showAlert('An actor with this name already exists!', 'error');
                return;
            }
            
            const actorData = {
                name: actorName,
                PinyinInitial: document.getElementById('actorPinyin').value,
                image: document.getElementById('actorImage').dataset.imageUrl || '',
                characters: []
            };
            
            if (actorId) {
                const index = DATA.ACTORS.findIndex(a => a.id === actorId);
                if (index !== -1) {
                    actorData.id = actorId;
                    actorData.characters = DATA.ACTORS[index].characters;
                    DATA.ACTORS[index] = actorData;
                    showAlert('Actor updated successfully');
                }
            } else {
                const newActor = {
                    id: getNextId(DATA.ACTORS),
                    ...actorData
                };
                DATA.ACTORS.push(newActor);
                showAlert('Actor added successfully');
            }
            
            saveState();
            resetActorForm();
            refreshLists();
        }

        function editActor(id) {
            const actor = DATA.ACTORS.find(a => a.id === id);
            if (actor) {
                document.getElementById('actorId').value = actor.id;
                document.getElementById('actorName').value = actor.name;
                document.getElementById('actorPinyin').value = actor.PinyinInitial || '';
                if (actor.image) {
                    document.getElementById('actorImagePreview').innerHTML = `<img src="${actor.image}" style="max-width: 100%; border-radius: 4px;">`;
                    document.getElementById('actorImage').dataset.imageUrl = actor.image;
                }
                document.getElementById('actorFormTitle').textContent = 'Edit Actor';
                document.getElementById('actorSubmitBtn').textContent = 'Update Actor';
                document.getElementById('actorCancelBtn').style.display = 'inline-block';
                document.getElementById('actorName').focus();
            }
        }

        function resetActorForm() {
            document.getElementById('actorForm').reset();
            document.getElementById('actorId').value = '';
            document.getElementById('actorImage').dataset.imageUrl = '';
            document.getElementById('actorImagePreview').innerHTML = '';
            document.getElementById('actorFormTitle').textContent = 'Add New Actor';
            document.getElementById('actorSubmitBtn').textContent = 'Add Actor';
            document.getElementById('actorCancelBtn').style.display = 'none';
            document.getElementById('actorName').focus();
        }

        function deleteActor(id) {
            if (confirm('Are you sure you want to delete this actor?')) {
                DATA.ACTORS = DATA.ACTORS.filter(actor => actor.id !== id);
                saveState();
                showAlert('Actor deleted successfully');
                refreshLists();
            }
        }

        function searchActors() {
            const searchTerm = document.getElementById('actorSearch').value.toLowerCase();
            const filteredActors = DATA.ACTORS.filter(actor => 
                actor.name.toLowerCase().includes(searchTerm) || 
                (actor.PinyinInitial && actor.PinyinInitial.toLowerCase().includes(searchTerm))
            );
            displayActors(filteredActors);
        }

        // Set Functions
        function saveSet(event) {
            event.preventDefault();
            const setId = document.getElementById('setId').value;
            const setName = document.getElementById('setName').value;
            
            // Check for duplicates
            if (isDuplicateName('SETS', setName, setId)) {
                showAlert('A set with this name already exists!', 'error');
                return;
            }
            
            let toneSections = {};
            try {
                const input = document.getElementById('setTones').value.trim();
                if (input) {
                    toneSections = JSON.parse(input);
                }
            } catch (e) {
                showAlert('Invalid JSON format for Tone Sections', 'error');
                return;
            }

            const setData = {
                name: setName,
                tone_sections: toneSections,
                image: document.getElementById('setImage').dataset.imageUrl || '',
                characters: []
            };
            
            if (setId) {
                const index = DATA.SETS.findIndex(s => s.id === setId);
                if (index !== -1) {
                    setData.id = setId;
                    setData.characters = DATA.SETS[index].characters;
                    DATA.SETS[index] = setData;
                    showAlert('Set updated successfully');
                }
            } else {
                const newSet = {
                    id: getNextId(DATA.SETS),
                    ...setData
                };
                DATA.SETS.push(newSet);
                showAlert('Set added successfully');
            }
            
            saveState();
            resetSetForm();
            refreshLists();
        }

        function editSet(id) {
            const set = DATA.SETS.find(s => s.id === id);
            if (set) {
                document.getElementById('setId').value = set.id;
                document.getElementById('setName').value = set.name;
                document.getElementById('setTones').value = JSON.stringify(set.tone_sections || {}, null, 2);
                if (set.image) {
                    document.getElementById('setImagePreview').innerHTML = `<img src="${set.image}" style="max-width: 100%; border-radius: 4px;">`;
                    document.getElementById('setImage').dataset.imageUrl = set.image;
                }
                document.getElementById('setFormTitle').textContent = 'Edit Set';
                document.getElementById('setSubmitBtn').textContent = 'Update Set';
                document.getElementById('setCancelBtn').style.display = 'inline-block';
                document.getElementById('setName').focus();
            }
        }

        function resetSetForm() {
            document.getElementById('setForm').reset();
            document.getElementById('setId').value = '';
            document.getElementById('setImage').dataset.imageUrl = '';
            document.getElementById('setImagePreview').innerHTML = '';
            document.getElementById('setFormTitle').textContent = 'Add New Set';
            document.getElementById('setSubmitBtn').textContent = 'Add Set';
            document.getElementById('setCancelBtn').style.display = 'none';
            document.getElementById('setName').focus();
        }

        function deleteSet(id) {
            if (confirm('Are you sure you want to delete this set?')) {
                DATA.SETS = DATA.SETS.filter(set => set.id !== id);
                saveState();
                showAlert('Set deleted successfully');
                refreshLists();
            }
        }

        function searchSets() {
            const searchTerm = document.getElementById('setSearch').value.toLowerCase();
            const filteredSets = DATA.SETS.filter(set => 
                set.name.toLowerCase().includes(searchTerm)
            );
            displaySets(filteredSets);
        }

        // Prop Functions
        function saveProp(event) {
            event.preventDefault();
            const propId = document.getElementById('propId').value;
            const propName = document.getElementById('propName').value;
            
            // Check for duplicates
            if (isDuplicateName('PROPS', propName, propId)) {
                showAlert('A prop with this name already exists!', 'error');
                return;
            }
            
            const propData = {
                name: propName,
                category: document.getElementById('propCategory').value,
                components: document.getElementById('propComponents').value
                    .split(',')
                    .map(c => c.trim())
                    .filter(c => c !== ''),
                image: document.getElementById('propImage').dataset.imageUrl || '',
                used_by: []
            };
            
            if (propId) {
                const index = DATA.PROPS.findIndex(p => p.id === propId);
                if (index !== -1) {
                    propData.id = propId;
                    propData.used_by = DATA.PROPS[index].used_by;
                    DATA.PROPS[index] = propData;
                    showAlert('Prop updated successfully');
                }
            } else {
                const newProp = {
                    id: getNextId(DATA.PROPS),
                    ...propData
                };
                DATA.PROPS.push(newProp);
                showAlert('Prop added successfully');
            }
            
            saveState();
            resetPropForm();
            refreshLists();
        }

        function editProp(id) {
            const prop = DATA.PROPS.find(p => p.id === id);
            if (prop) {
                document.getElementById('propId').value = prop.id;
                document.getElementById('propName').value = prop.name;
                document.getElementById('propCategory').value = prop.category;
                document.getElementById('propComponents').value = prop.components ? prop.components.join(', ') : '';
                if (prop.image) {
                    document.getElementById('propImagePreview').innerHTML = `<img src="${prop.image}" style="max-width: 100%; border-radius: 4px;">`;
                    document.getElementById('propImage').dataset.imageUrl = prop.image;
                }
                document.getElementById('propFormTitle').textContent = 'Edit Prop';
                document.getElementById('propSubmitBtn').textContent = 'Update Prop';
                document.getElementById('propCancelBtn').style.display = 'inline-block';
                document.getElementById('propName').focus();
            }
        }

        function resetPropForm() {
            document.getElementById('propForm').reset();
            document.getElementById('propId').value = '';
            document.getElementById('propImage').dataset.imageUrl = '';
            document.getElementById('propImagePreview').innerHTML = '';
            document.getElementById('propCategory').value = 'general';
            document.getElementById('propFormTitle').textContent = 'Add New Prop';
            document.getElementById('propSubmitBtn').textContent = 'Add Prop';
            document.getElementById('propCancelBtn').style.display = 'none';
            document.getElementById('propName').focus();
        }

        // Character Functions
        function saveCharacter(event) {
            event.preventDefault();
            const characterId = document.getElementById('characterId').value;
            const selectedProps = Array.from(document.getElementById('charProps').selectedOptions).map(opt => opt.value);
            
            const characterData = {
                hanzi: document.getElementById('charHanzi').value,
                pinyin: document.getElementById('charPinyin').value,
                meaning: document.getElementById('charMeaning').value,
                actor: document.getElementById('charActor').value,
                set_location: document.getElementById('charSet').value,
                tone_section: document.getElementById('charToneSection').value,
                props: selectedProps,
                plot: document.getElementById('charPlot').value,
                image: document.getElementById('charImage').dataset.imageUrl || '',
                memory_scene: "",
                audio_file: ""
            };
            
            if (characterId) {
                const index = DATA.CHARACTERS.findIndex(c => c.id === characterId);
                if (index !== -1) {
                    characterData.id = characterId;
                    DATA.CHARACTERS[index] = characterData;
                    showAlert('Character updated successfully');
                }
            } else {
                const newCharacter = {
                    id: getNextId(DATA.CHARACTERS),
                    ...characterData
                };
                DATA.CHARACTERS.push(newCharacter);
                showAlert('Character added successfully');
            }
            
            saveState();
            resetCharacterForm();
            refreshLists();
        }

        function editCharacter(id) {
            const character = DATA.CHARACTERS.find(c => c.id === id);
            if (character) {
                document.getElementById('characterId').value = character.id;
                document.getElementById('charHanzi').value = character.hanzi;
                document.getElementById('charPinyin').value = character.pinyin;
                document.getElementById('charMeaning').value = character.meaning;
                document.getElementById('charActor').value = character.actor;
                document.getElementById('charSet').value = character.set_location;
                document.getElementById('charPlot').value = character.plot || '';
                if (character.image) {
                    document.getElementById('charImagePreview').innerHTML = `<img src="${character.image}" style="max-width: 100%; border-radius: 4px;">`;
                    document.getElementById('charImage').dataset.imageUrl = character.image;
                }
                
                updateToneSections();
                
                setTimeout(() => {
                    document.getElementById('charToneSection').value = character.tone_section || '';
                }, 100);
                
                const propsSelect = document.getElementById('charProps');
                Array.from(propsSelect.options).forEach(option => {
                    option.selected = character.props.includes(option.value);
                });
                
                document.getElementById('characterFormTitle').textContent = 'Edit Character';
                document.getElementById('characterSubmitBtn').textContent = 'Update Character';
                document.getElementById('characterCancelBtn').style.display = 'inline-block';
                document.getElementById('charHanzi').focus();
            }
        }

        function resetCharacterForm() {
            document.getElementById('characterForm').reset();
            document.getElementById('characterId').value = '';
            document.getElementById('charImage').dataset.imageUrl = '';
            document.getElementById('charImagePreview').innerHTML = '';
            document.getElementById('characterFormTitle').textContent = 'Add New Character';
            document.getElementById('characterSubmitBtn').textContent = 'Add Character';
            document.getElementById('characterCancelBtn').style.display = 'none';
            refreshCharacterForm();
            document.getElementById('charHanzi').focus();
        }

        function deleteCharacter(id) {
            if (confirm('Are you sure you want to delete this character?')) {
                DATA.CHARACTERS = DATA.CHARACTERS.filter(char => char.id !== id);
                saveState();
                showAlert('Character deleted successfully');
                refreshLists();
            }
        }

        function searchCharacters() {
            const searchTerm = document.getElementById('characterSearch').value.toLowerCase();
            
            const filteredCharacters = DATA.CHARACTERS.filter(character => {
                const actor = DATA.ACTORS.find(a => a.id === character.actor);
                const set = DATA.SETS.find(s => s.id === character.set_location);
                
                return character.hanzi.toLowerCase().includes(searchTerm) ||
                       character.pinyin.toLowerCase().includes(searchTerm) ||
                       character.meaning.toLowerCase().includes(searchTerm) ||
                       (actor && actor.name.toLowerCase().includes(searchTerm)) ||
                       (set && set.name.toLowerCase().includes(searchTerm));
            });
            
            displayCharacters(filteredCharacters);
        }

        // Display Functions
        function refreshLists() {
            displayActors();
            displaySets();
            displayProps();
            displayCharacters();
        }

        function displayActors(actorsToDisplay = null) {
            const actors = actorsToDisplay || DATA.ACTORS;
            const targetContainer = document.getElementById('actorsList');
            
            if (actors.length === 0) {
                targetContainer.innerHTML = '<div class="empty-state">No actors found. Add your first actor above.</div>';
                return;
            }
            
            targetContainer.innerHTML = actors.map(actor => {
                const charCount = getCharacterCountForActor(actor.id);
                return `
                <div class="item-card">
                    ${actor.image ? `<img src="${actor.image}" style="max-width: 100%; height: 150px; object-fit: cover; border-radius: 4px; margin-bottom: 10px;">` : ''}
                    <h4>${actor.name} <span class="character-count">${charCount}</span></h4>
                    <p>Pinyin: ${actor.PinyinInitial || 'N/A'}</p>
                    <p>Characters: ${charCount}</p>
                    <div class="item-actions">
                        <button class="edit-btn" onclick="editActor('${actor.id}')">Edit</button>
                        <button class="delete-btn" onclick="deleteActor('${actor.id}')">Delete</button>
                    </div>
                </div>
                `;
            }).join('');
        }

        function displaySets(setsToDisplay = null) {
            const sets = setsToDisplay || DATA.SETS;
            const targetContainer = document.getElementById('setsList');
            
            if (sets.length === 0) {
                targetContainer.innerHTML = '<div class="empty-state">No sets found. Add your first set above.</div>';
                return;
            }
            
            targetContainer.innerHTML = sets.map(set => {
                const charCount = getCharacterCountForSet(set.id);
                const toneSections = set.tone_sections || {};
                return `
                <div class="item-card">
                    ${set.image ? `<img src="${set.image}" style="max-width: 100%; height: 150px; object-fit: cover; border-radius: 4px; margin-bottom: 10px;">` : ''}
                    <h4>${set.name} <span class="character-count">${charCount}</span></h4>
                    <p>Tone Sections: ${Object.keys(toneSections).length}</p>
                    <p>Characters: ${charCount}</p>
                    <div class="tone-sections">
                        ${Object.entries(toneSections).map(([key, value]) => 
                            `<span class="tone-section-item">${key}: ${value}</span>`
                        ).join('')}
                    </div>
                    <div class="item-actions">
                        <button class="edit-btn" onclick="editSet('${set.id}')">Edit</button>
                        <button class="delete-btn" onclick="deleteSet('${set.id}')">Delete</button>
                    </div>
                </div>
                `;
            }).join('');
        }

        function displayProps(propsToDisplay = null) {
            const props = propsToDisplay || DATA.PROPS;
            const targetContainer = document.getElementById('propsList');
            
            if (props.length === 0) {
                targetContainer.innerHTML = '<div class="empty-state">No props found. Add your first prop above.</div>';
                return;
            }
            
            targetContainer.innerHTML = props.map(prop => {
                const charCount = getCharacterCountForProp(prop.id);
                return `
                <div class="item-card">
                    ${prop.image ? `<img src="${prop.image}" style="max-width: 100%; height: 150px; object-fit: cover; border-radius: 4px; margin-bottom: 10px;">` : ''}
                    <h4>${prop.name} <span class="character-count">${charCount}</span></h4>
                    <p>Category: ${prop.category}</p>
                    <p>Components: ${prop.components ? prop.components.join(', ') : 'None'}</p>
                    <p>Used by: ${charCount} characters</p>
                    <div class="item-actions">
                        <button class="edit-btn" onclick="editProp('${prop.id}')">Edit</button>
                        <button class="delete-btn" onclick="deleteProp('${prop.id}')">Delete</button>
                    </div>
                </div>
                `;
            }).join('');
        }

        function displayCharacters(charactersToDisplay = null) {
            const characters = charactersToDisplay || DATA.CHARACTERS;
            const targetContainer = document.getElementById('charactersList');
            
            if (characters.length === 0) {
                targetContainer.innerHTML = '<div class="empty-state">No characters found. Add your first character above.</div>';
                return;
            }
            
            targetContainer.innerHTML = characters.map(character => {
                const actor = DATA.ACTORS.find(a => a.id === character.actor);
                const set = DATA.SETS.find(s => s.id === character.set_location);
                const characterProps = DATA.PROPS.filter(p => character.props.includes(p.id));
                
                let toneSectionDisplay = character.tone_section;
                if (set && set.tone_sections && set.tone_sections[character.tone_section]) {
                    toneSectionDisplay = `${character.tone_section}: ${set.tone_sections[character.tone_section]}`;
                }
                
                return `
                <div class="item-card">
                    ${character.image ? `<img src="${character.image}" style="max-width: 100%; height: 150px; object-fit: cover; border-radius: 4px; margin-bottom: 10px;">` : ''}
                    <h4>${character.hanzi}</h4>
                    <p>Pinyin: ${character.pinyin}</p>
                    <p>Meaning: ${character.meaning}</p>
                    <p>Actor: ${actor ? actor.name : 'N/A'}</p>
                    <p>Set: ${set ? set.name : 'N/A'}</p>
                    <p>Tone Section: ${toneSectionDisplay}</p>
                    <p>Props: ${characterProps.map(p => p.name).join(', ') || 'None'}</p>
                    ${character.plot ? `<p><strong>Plot:</strong> ${character.plot}</p>` : ''}
                    <div class="item-actions">
                        <button class="edit-btn" onclick="editCharacter('${character.id}')">Edit</button>
                        <button class="delete-btn" onclick="deleteCharacter('${character.id}')">Delete</button>
                    </div>
                </div>
                `;
            }).join('');
        }

        // Initialize on Page Load
        document.addEventListener('DOMContentLoaded', async function() {
            await loadDataFromFiles();
            saveState();
            
            refreshLists();
            refreshCharacterForm();
            setupKeyboardNavigation();
            refreshAdvancedSearchOptions();
            
            // Setup image preview handlers
            document.getElementById('actorImage')?.addEventListener('change', (e) => previewImage(e.target, 'actorImagePreview'));
            document.getElementById('setImage')?.addEventListener('change', (e) => previewImage(e.target, 'setImagePreview'));
            document.getElementById('propImage')?.addEventListener('change', (e) => previewImage(e.target, 'propImagePreview'));
            document.getElementById('charImage')?.addEventListener('change', (e) => previewImage(e.target, 'charImagePreview'));
            
            // Store image data URLs on form submission
            document.getElementById('actorForm')?.addEventListener('submit', async (e) => {
                const img = await getImageDataURL(document.getElementById('actorImage'));
                if (img) document.getElementById('actorImage').dataset.imageUrl = img;
            });
            document.getElementById('setForm')?.addEventListener('submit', async (e) => {
                const img = await getImageDataURL(document.getElementById('setImage'));
                if (img) document.getElementById('setImage').dataset.imageUrl = img;
            });
            document.getElementById('propForm')?.addEventListener('submit', async (e) => {
                const img = await getImageDataURL(document.getElementById('propImage'));
                if (img) document.getElementById('propImage').dataset.imageUrl = img;
            });
            document.getElementById('characterForm')?.addEventListener('submit', async (e) => {
                const img = await getImageDataURL(document.getElementById('charImage'));
                if (img) document.getElementById('charImage').dataset.imageUrl = img;
            });
            
            // Focus first field on initial load
            document.getElementById('actorName').focus();
        });
    </script>
</body>
</html>